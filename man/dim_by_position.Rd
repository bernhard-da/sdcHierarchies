% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dim_by_position.R
\name{dim_by_position}
\alias{dim_by_position}
\title{dim_by_position}
\usage{
dim_by_position(dim, dim_spec, tot_lev = NULL, full_names = TRUE,
  method = "len", as_df = FALSE)
}
\arguments{
\item{dim}{a character vector containing codes of a hierarchical variables.}

\item{dim_spec}{an (integerish) vector containing either the length (in terms of characters) for each level or the
end-positions of these levels. In the latter-case, one needs to set argument \code{method} to \code{"endpos"}}

\item{tot_lev}{\code{NULL} or a scalar characer specifying the name of the overall total in case it is not encoded at the
first positions of \code{dim}}

\item{full_names}{(logical) should full names or short-names be returned}

\item{method}{either \code{len} (the default) or \code{endpos}
\itemize{
\item \code{len}: the number of characters for each of the levels needs to be specified
\item \code{endpos}: the end-positions for each levels need to be fixed
}}

\item{as_df}{(logical) if \code{FALSE}, a data.tree is returned, else a data.frame suitable as input for tau-argus}
}
\value{
a hierarchical data structure depending on choice of argument \code{as_df}
}
\description{
dim_by_position
}
\examples{
## nuts: digits 1-2 (nuts1), digit 3 (nut2), digits 4-5 (nuts3)
## all strings have equal length but total is not encoded in these values
geo_m <- c(
  "01051","01053","01054","01055","01056","01057","01058","01059","01060","01061","01062",
  "02000",
  "03151","03152","03153","03154","03155","03156","03157","03158","03251","03252","03254","03255",
  "03256","03257","03351","03352","03353","03354","03355","03356","03357","03358","03359","03360",
  "03361","03451","03452","03453","03454","03455","03456",
  "10155")
a <- dim_by_position(dim=geo_m, dim_spec=c(2,3,5),
  full_names=TRUE, tot_lev="Tot", method="endpos")
b <- dim_by_position(dim=geo_m, dim_spec=c(2,1,2),
  full_names=TRUE, tot_lev="Tot", method="len")
identical(ToDataFrameTypeCol(a), ToDataFrameTypeCol(b))

## return data.frame suitable as input for tau-argus or sdcTable
a <- dim_by_position(dim=geo_m, dim_spec=c(2,3,5), full_names=TRUE,
  tot_lev="Tot", method="endpos", as_df=TRUE)
b <- dim_by_position(dim=geo_m, dim_spec=c(2,1,2), full_names=TRUE,
  tot_lev="Tot", method="len", as_df=TRUE)
identical(a, b)

## total is contained in the first 3 positions of the input values
## --> we need to set tot_level to NULL (the default)
geo_m_with_tot <- paste0("Tot",geo_m)
a <- dim_by_position(dim=geo_m_with_tot, dim_spec=c(3,2,1,2),
  full_names=TRUE, method="len", as_df=TRUE)
b <- dim_by_position(dim=geo_m_with_tot, dim_spec=c(3,5,6,8),
  full_names=TRUE, method="endpos", as_df=TRUE)
identical(a, b)

## second example, unequal strings; overall total not included in input
yae_h <- c(
  "1.1.1.","1.1.2.",
  "1.2.1.","1.2.2.","1.2.3.","1.2.4.","1.2.5.","1.3.1.",
  "1.3.2.","1.3.3.","1.3.4.","1.3.5.",
  "1.4.1.","1.4.2.","1.4.3.","1.4.4.","1.4.5.",
  "1.5.","1.6","1.7.","1.8.","1.9.","2.","3.")
a <- dim_by_position(dim=yae_h, dim_spec=c(2,4,6) , full_names=TRUE, tot_lev="Tot", method="endpos")
b <- dim_by_position(dim=yae_h, dim_spec=c(2,2,2), full_names=TRUE, tot_lev="Tot", method="len")
identical(ToDataFrameTypeCol(a), ToDataFrameTypeCol(b))

## total is contained in the first 3 positions of the input values
## --> we need to set tot_level to NULL (the default)
yae_h_with_tot <- paste0("Tot",yae_h)
a <- dim_by_position(dim=yae_h_with_tot, dim_spec=c(3,2,2,2),
full_names=TRUE, method="len", as_df=TRUE)
b <- dim_by_position(dim=yae_h_with_tot, dim_spec=c(3,5,7,9),
  full_names=TRUE, method="endpos", as_df=TRUE)
identical(a, b)
}
